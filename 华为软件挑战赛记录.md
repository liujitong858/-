# 华为软件精英赛

## 4月7号

- 完成初步框架的思路整理
- 代码框架参考了 [ https://zhuanlan.zhihu.com/p/125764650 ]:
- 使用二维数组保存转账记录
- 使用dfs进行有向图环的寻找
- 可以通过官方样例

## 4月8号

- 考虑拓扑排序的思想
- 完成对有向图的剪枝操作
- 在官方数据上，速度有80ms的提升
- **但是剪枝操作只对稀疏图有较好的改进，稠密图几乎没有优化**
- 考虑将最后三层递归操作转为循环操作，测试时间变长，失败
- 提交作品，编译失败

## 4月9号

- 考虑加入多线程的思想
- 昨天编译失败的原因主要是没有在linux系统上进行cpp的编译
- 对领取的服务器进行一些基本操作的熟悉
- 领取的2U8G服务器上 对于28W transfer_record 3Wnode 100Wcircle 进行测试 ；
- **测试结果为95s左右**
- **提交结果：官方评分8.6，排名11**

## 4月10号

- 突然对8号优化失败的程序有了新的想法
- 将3层循环换成2层循环，最多5层递归
- 测试结果：对于28W transfer_record 3Wnode 100Wcircle 单线程 时间为 163s
- 输出采用fwrite代替ofsteam 百万级输出优化1.3s
- 继续考虑多线程的优化，分别对1-8个线程的程序进行了时间测试
- **在测试服务器上，多线程的优化只存在1或者n，最终还是采用了4线程提交**
- **提交结果：官方评分6.4，排名22（大佬们已经开始了）**

## 4月11号

- 新想法是如果存在环的话一定存在，高向低，定义为反向转账
- 我们首先可以找出所有反向转账和正向转账
- 将两个数组大小进行比较，将小的数组的size()作为dfs外循环的次数
- 这种算法需要考虑两个过程：
  - 对重复路径的去重
  - 路径最后的排序（其实原来算法中也有考虑）
- 目标是减少外层大循环的次数
- 在实际测试中发现，一个ID是可能给多个ID转账的，而目标ID有大有小
- 之前算法中的：因为是从映射索引最小的顶点开始寻找，所以顶点ID越大，递归次数越少，进行速度越快  这一点也摒弃了，导致每一个顶点递归时间和一开始速度一样慢，从而影响了整体时间
- **经过测试，新的方案搁浅**

## 4月12号

- 今天我们团队休息，没有进展
- 考虑周一对线程亲和性的设置进行研究设置以提高CPU利用率
- 提交了一下非多线程版本的最新程序
- 得分7.8，比使用多线程相同程序版本少1分
- 排名爆炸

## 4月13号

- 对Neon（ARM架构处理器扩展结构）指令集编程进行了一些了解
- 参考了网上对于linux设置线程亲和性的代码
- 将优化了线程亲和性的代码放到测试服务器上测试
- 测试结果表明：
  - 单线程确实不如多线程的速度
  - 如果线程数量超出了CPU的数量，效果就无增长了
  - 2线程和4线程在本地测试数据实际上没有区别
- 根据我们的推理，如果在比赛服务器代码中设置4线程亲和，效果可能更好。

- **比赛服务器中4线程亲和测试结果与之前4线程版本几乎一样**
- **结论跟我们之前的假设实际上是冲突的，那么只有一种可能，就是服务器上本身就已经设置了线程软亲和性了，在此基础上已经将CPU利用率扩展到最大了。即多线程的使用是1和0的区别**

## 4月14号

- 尝试对DFS算法部分进行优化
- 优化方向是考虑不去走相同的路径
- 但是由于优化比较复杂在代码过程中遇到了很多困难

## 4月15号

- ```cpp
  int ans3[3*500000];
  int ans4[4*500000];
  int ans5[5*1000000];
  int ans6[6*2000000];
  int ans7[7*3000000];
  ```

- 长度为x的环最大的数量
- 没有任何进展

 



 